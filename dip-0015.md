<pre>
  DIP: 0015
  Title: DashPay
  Author(s): Samuel Westrich, Eric Britten
  Special-Thanks: Alex Werner, Andrei Baranouski, Andrew Podkovyrin, Balazs Kiraly, Brian Foster, Ivan Shumkov, Pasta, Samuel Barbosa, Thephez, Tomasz Ludek
  Comments-Summary: No comments yet.
  Status: Proposed
  Type: Standard
  Created: 2020-12-02
  License: MIT License
</pre>

# Table of Contents

1. [Abstract](#abstract)
1. [Motivation](#motivation)
1. [Prior Work](#prior-work)
1. [Terminology](#terminology)
1. [DashPay Features](#dashpay-features)
1. [DashPay: Establishing Relationships between Dash Identities](#dashpay-establishing-relationships-between-dash-identities)
1. [The DashPay Contract](#the-dashpay-contract)
    * [What is in the DashPay contract](#what-is-in-the-dashpay-contract)
    * [The Contact Request](#the-contact-request)
    * [The Profile](#the-profile)
    * [Contact Info](#contact-info)
1. [Example Steps to Establish a Contact](#example-steps-to-establish-a-contact)
1. [Order of Synchronization](#order-of-synchronization)
1. [Copyright](#copyright)

# Abstract

DashPay is an application built on Dash Platform that creates bidirectional direct settlement payment channels between Dash Identities. This document details the process of implementing DashPay inside a wallet.

# Motivation

At the time of writing there exists a large divide between what is expected from a modern user experience when making a payment and the current state of decentralized cryptocurrencies.

A spender generally wants three things:

1. Payments are easy to perform.
2. A history of payments is readily available.
3. Third parties aren't knowledgeable about the details of the payment.

A merchant generally also wants three things:

1. Settlement is instantaneous.
2. Settlement is guaranteed.
3. Payments are easy to tally up for later accounting purposes.

While several of these have already been or are being solved in Dash, DashPay aims to tackle the ease of use aspect of payments as well as improving transaction history. For payments to be considered easy, users should not have to rely on side channels to exchange payment information (e.g. crypto addresses, payment links, SEPA). In order to achieve this, DashPay moves Contacts front and center. All users have a contact list and can easily pay their friends. From a user perspective, making a payment to a contact is much easier than asking them to provide an address and without verifying the address is exactly right. An added benefit is that the recipient knows and will always know the sender, hence contact history will always show who made a payment to the user, or who the user made a payment to. This better aligns with modern payment experiences.

# Prior work

We will refer to prior work whereby of particular note are:

* [BIP-0032: Hierarchical Deterministic Wallets](https://github.com/dashevo/bips/blob/master/bip-0032.mediawiki)
* [BIP-0044: Multi-Account Hierarchy for Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki)
* [DIP 0009: Coin Specific Feature Derivation Paths](https://github.com/dashpay/dips/blob/master/dip-0009.md)
* [DIP-0011: Identities](https://github.com/dashpay/dips/blob/master/dip-0011.md)
* [DIP-0013: Identities in Hierarchical Deterministic wallets](./dip-0013.md)
* [DIP-0014: Extended Key Derivation using 256-bit Unsigned Integers](./dip-0014.md)
* [DIP-0016: Simple Payment Verification Wallet Headers First Synchronization](./dip-0016.md)

# Terminology

In the rest of the document we will refer to multiple concepts that we will hereby explain:

**Derivation Path:** A derivation path is a path of successionally derived keys as defined in BIP32. For the purpose of this document, when referring to a derivation path we will generally mean the derivation path before the key space used for addresses even though the keys used for addresses each have their own derivation path.

**Address space:** The address space is the universe of addresses defined by the derivation path derived to termination paths, such as internal/external in classical derivation paths and indexes.

**Extended Public Key:** The extended public key is the public key of a derivation path along with some extra information defined in BIP32 needed to construct the address space. These addresses are not spendable with just the extended public key.

**Extended Private Key:** The extended private key is the private key of a derivation path. With it you can always figure out the extended public key.

**Extended Key Pair:** This is a generalization of the extended private key, since it always can generate the extended public key.

**Identity (or Dash identity):** In DashPay each user is identified by their Dash identity. An identity has a 256-bit unique identifier that should be displayed to users in Base58. DashPay uses this unique identifier as a foreign key in contact requests, profiles and contact info.

**Username:** This is the name defined in the Dash Platform Name Service (DPNS) domain document's `label` property under the `.dash` parent level domain. It is used in a client's user interface to uniquely identify a user (identity) in a human readable way.

**Sender (Source):** The identity that makes a contact request to another identity. It is also referred to as the source of the contact request.

**Recipient (Destination):** The identity that receives a contact request from another identity. It is also referred to as the destination of the contact request.

**Contact Request:** A platform document that defines a one way relationship between a sender and a recipient. It includes an encrypted extended public key which will allow the sender to pay the recipient using addresses that other users have no knowledge of. The sender creates and publishes this document. When two users have both sent contact requests to each other, then each is considered a fully established contact with the other.

**Friendship:** A two way relationship established by two users who have sent contact requests to each other. This is a technical term and should not be shown to end users.

**Contact:** For a user, a contact is the other side of an established friendship.

**Direct Settlement Payment Channel (DSPC):** Established contacts have address spaces to send and receive from each other. When these are present either in one way or bi-directional we will call this a direct settlement payment channel.

**Profile:** A document containing a set of public information for an identity that includes a display name, a public message (bio/status) and an avatar URL. The display name and avatar help complement the identity's username from DPNS to better visually identify an identity in a user interface. An identity can only have a single DashPay profile.

**Contact info:** A document containing an identity's set of private information related to other identities that are contacts.

**Peer**: A node that transmits and receives information to and from the client through any combination of Dash Core peer to peer or DAPI.

# DashPay Features

## User Centric

Traditional crypto wallets have long been designed with no user interactions. This was mostly due to the technological environment in the cryptocurrency space. Non-crypto wallets that have gained market share around the world all have a social aspect to them. DashPay is designed to bridge this gap and bring users front and center in a cryptocurrency wallet. Instead of sending to an address, a user sends directly to another user. Users will have a username, a display name, an avatar and a quick bio/information message. A user can also nickname other users to remember them better.

## Making Payments Easy

Once two users have exchanged contact requests, each can make payments to the other without manually sharing addresses via emails, texts or BIP21 QR codes. This is because every contact request contains the information required to send payments to the originator of the request. More precisely, an encrypted extended public key is sent in the contact request. When decrypted, this extended public key can be used by the recipient of the contact request to generate payment addresses for the originator of the contact request. The recipient must watch for transactions to those addresses (i.e. SPV clients need to add these addresses to the bloom filters).

## Providing a Payment History

When a contact is established, a user can easily track the payments they have sent to another user and the payments that they have received from that other user. A user will have an extended private key to track payments that are received from the other user and an extended public key to track payments that are sent to that other user.

## Protecting Payment Participants

Although contact requests are public in Dash Platform, the extended public keys are encrypted in such a way that only the two users involved in a contact's two way relationship can decrypt those keys. This ensures that when any two users make payments in DashPay, only they know the sender and receiver while 3rd parties do not. This means that outside observers cannot link the identities involved in the transaction. Addresses in DashPay are intended to be single use and internal to the system only, as users will never see them. They should never be reused. PrivateSend funds can also be used in DashPay, though a PrivateSend mixing feature is not a requirement of a DashPay enabled wallet.

# DashPay: Establishing Relationships between Dash Identities

Dash based identities are defined in [DIP11](https://github.com/dashpay/dips/blob/master/dip-0011.md). In DashPay it is essential to understand that all relationships are between these identities. A Dash identity is referenced by its unique identifier. A friendship in DashPay is nothing more than two contact requests between Dash identities; one in each direction. DashPay clients should not use the term "friend" and instead use the term "contact". While this document uses the term friendship for a completed relationship between two contacts, this will remain a technical term. It should not be presented to end users and should only be used in technical documents for clarity.

# The DashPay Contract

DashPay is one of the first applications of Dash Platform's Data Contracts. Data Contracts are a set of structured document types. The DashPay contract has the following requirements:

* A Hierarchical Deterministic capable wallet
* Control over a registered Dash identity

## What is in the DashPay Contract?

The contract defines three document types: `contactRequest`, `profile` and `contactInfo`. ContactRequest documents are used to establish relationships and payment channels between Dash identities. Profile documents are used to store public facing information about Dash identities. Lastly contactInfo documents are used to store private information about other Dash identities.

A JSON Schema representation of the DashPay contract is associated with this document and can be found here. The three document types are described in further detail in the following sections.

## The Contact Request

A `contactRequest` document defines a one-way relationship between the sender identity and the recipient identity. The document type's properties are as follows:

* $ownerId (byte array) - The unique id of the sender.
* toUserId (byte array) - The unique id of the recipient.
* senderKeyIndex (integer) - The index of the sender's identity public key. Used to derive the ECDH key.
* recipientKeyIndex (integer) - The index of the recipient's identity public key. Used to derive the ECDH key.
* accountReference (integer) - A reference to the account from which the extended public key originated. This is encrypted for the sender. The recipient should disregard this field.
* encryptedAccountLabel (byte array, optional) - An encrypted message to the recipient of the contact request that should be the label of the sender's account.
* encryptedPublicKey (byte array) - The sender's extended public key that is encrypted with an ECDH shared key that will be defined below.
* autoAcceptProof (byte array, optional) - An optional field intended to be used to provide proof to recipients to automatically accept the contact request.
* $coreHeightCreatedAt (integer) - The last chain locked block height known by Dash Platform at the time of document creation.
* $createdAt (integer) - The timestamp in milliseconds when this document was created.

Note: Properties prefixed with a `$` sign are special system-wide predefined properties that inherit from the base protocol definition.

### Binary Property Validation Sizes

The Contact Request has five binary properties. Their sizes are defined as follows:

| Name | Size |
| - | - |
| $ownerId | 32 bytes |
| toUserId | 32 bytes |
| encryptedAccountLabel | 48-80 bytes |
| encryptedPublicKey | 96 bytes |
| autoAcceptProof | 38-102 bytes |

### Dash Identities ($ownerId and toUserId)

The `$ownerId` should be set to the identity unique id of the sender that will be making a contact request. The recipient's identity unique id is specified in `toUserId`. Together `$ownerId`, `toUserId` and `accountReference` form the unique primary key of the `contactRequest`. A client can query contact requests based off of `$ownerId` and `$createdAt` to receive outgoing contact requests and can query contact requests based off of `toUserId` and `$createdAt` to receive incoming contact requests. While less common, a device can also query contact requests off of `$ownerId` and `toUserId` to see if any contact requests exist.

### ECDH Shared Key (senderKeyIndex and recipientKeyIndex)

In order to decrypt and encrypt between recipient and sender, a shared key must be created using a Diffie-Hellman key exchange. This shared key is derived using the libsecp256k1_ecdh method which differs from standard ECDH as defined by other standard crypto libraries. The same shared key can be created based off of a Diffie-Hellman Key Exchange by both the sender and the recipient as follows:

* The private key at `senderKeyIndex` of the sender and the public key at `recipientKeyIndex` of the recipient
* The private key at the `recipientKeyIndex` of the recipient and the public key at `senderKeyIndex` of the sender

Either set of private and public keys mentioned above can be used to derive the same point on the curve (x, y). The standard ECDH key would be the x coordinate. However, libsecp256k1_ecdh has one extra step to derive the shared key, which is to calculate `SHA256((y[31]&0x1|0x2) || x)` where `|` is bitwise or and `||` is concatenation. This is essential to protect against leaking private key information as both keys are static.

This shared key is used to encrypt the extended public key and the encrypted account label.

### The account reference (accountReference)

BIP32 details the idea that a wallet can have multiple accounts. For example, a wallet can have a business account, a personal account, a savings account and many more. Identities are not account based. As described in [DIP13 (Identities in Hierarchical Deterministic Wallets)](./dip-0013.md), identities represent a persona. DashPay uses contact requests to establish relationships between identities in the context of two accounts. Each contact request is set up to receive payments to an account.

Unlike the extended public key that is intended for the recipient of the request, the account reference is solely an indicator for the sender. A contact request from Bob to Carol assigned to account zero indicates to Bob that this relationship is associated with his wallet account at index zero. As an example, Bob's account zero could be his personal account and account one his professional account. He could make a contact request to Carol on his personal account zero since Carol is his friend, then make another contact request to his colleague Marc who deals with company reimbursements on account one. When Marc sends him a payment, the funds will be added to his professional account.

The account reference is constructed the following way by the recipient:

Create the account secret key (ASK):

``` text
ASK = HMAC(senderSecretKey, extendedPublicKey)
ASK28 = 28 most significant bits of ASK
ShortenedAccountBits = Account & 0x0FFFFFFF
VersionBits = Version << 28
AccountRef = VersionBits | (ASK28 xor ShortenedAccountBits)
```

While the 28 bits used in the `ASK28` are not enough to guarantee uniqueness, uniqueness is not a requirement of this system. The probability of two contact requests having the same `ASK28` is 2<sup>28</sup>. The birthday paradox might lead to some contact requests eventually having the same `ASK28`, however this does not pose an attack. The key can be considered a one time pad as it is only used to encrypt one message per friendship; if the account would change so would the `extendedPublicKey`. Since the `extendedPublicKey` is derived using the account as one source of entropy, `ASK28` can be considered the result of a pseudorandom function derived from the account.

The Version field should generally be set to zero. More advanced clients can optionally offer the following scheme to their users: if receiving any number other than zero, and while also having a contact request with the previous version, clients should notify the recipient user of the contact request that the sender has updated their payment addresses. If accepted by the recipient, they should update the accepted account to the AccountRef in their `contactInfo` document for the sender.

If an identity (Bob) has already received a contact request from another identity (Carol), the client should either disregard all future contact requests from Carol, or preferably ask the user (Bob) to which destination account he wishes to send a payment.

### The encrypted account label (encryptedAccountLabel)

If desired, a sender can assign an encrypted account name in the contact request that can be decrypted by the recipient. This is useful when a user has multiple accounts on their device. We can imagine a scenario where a user would only wish to receive business-related reimbursements to one account, while using another account for personal expenses. When sending the second contact request, the user should explain its purpose so that the destination user will have readable options when sending a payment.

The encryptedAccountLabel property is a binary field that has the following format once it is deserialized to bytes:

* Initialization Vector (16 bytes)
* The account label with padding (32-64 bytes) that is encrypted by CBC-AES-256 using the shared ECDH key

### Encrypted Extended Public Key (encryptedPublicKey)

A contact request from Bob to Carol should contain an encrypted extended public key that Bob makes for Carol. Once Carol decrypts this extended public key, she can use it to derive keys representing the unique addresses where her payments to Bob should be sent.

The `encryptedPublicKey` property is a binary field that has the following format once it is deserialized to bytes:

* Initialization Vector (16 bytes)
* Encrypted extended public key with padding (80 bytes) that is encrypted by CBC-AES-256 using a shared ECDH key

The initialization vector used to encrypt the extended public key and the initialization vector used to encrypt the account label must be both different from each other and random.

The data format of the extended public key differs from what is defined in the Serialization Format of BIP32. This is because only the following fields are necessary when constructing derivations. The binary format used is as follows:

* Parent fingerprint (4 bytes)
* Chain code (32 bytes)
* Public Key  (33 bytes)

Deriving the extended public key in the wallet is described in its own section later in this document.

### Core Height ($coreHeightCreatedAt)

This field is meant to represent the height of the most recent ChainLocked block on the core Dash chain. Dash Platform includes this height with a slight delay as part of its state and updates it through platform chain block headers. This field is essential for receiving all payments between contacts.

When submitting a contact request, clients should first query this value from Dash Platform to be able to include it in the contact request. During validation, Platform will accept values that correspond to the last 5 ChainLocks known by the platform state.

Let us demonstrate the problem and why this field is important with the following example. User Bob is using DashPay on multiple devices: device A and device B. Both devices are synced to height n. Using Device A, Bob sends a contact request to Carol who immediately sends him a payment that is mined in a block on height n+1. Device B in the meantime has synced to height n+1 already and has not received the payment because it was not yet aware of the outgoing contact request. When it receives the outgoing contact request at height n+1, it updates its filter but will never receive the payment transaction as it is not in mempool and was already mined in the previously received block n+1.

Now let us demonstrate how this is fixed by including a core height in the request. Both devices are synced to height n. Using Device A, Bob sends a contact request with core height n to Carol. Carol once again immediately sends him a payment request that is mined on height n+1. As before, Device B has synced to height n+1 already and has not received the payment because it was not aware of the outgoing contact request. Still at height n+1, when it receives the outgoing contact, it sees that the contact request could have received payments in block n+1. Since n+1 has already been synced, it needs to resync blocks from height n+1 after updating its bloom filter. It will then receive the transaction that was mined at block n+1.

### Created At Timestamp ($createdAt)

The timestamp in milliseconds since the unix epoch time when the contact request was created. This field is useful when fetching new contact requests. When a DashPay client starts up, it should query contact requests, both incoming and outgoing, using this property. It should query contact requests that were created at most 10 minutes before the most recent contact request that the wallet knows about. Dash Platform allows documents with a `$createdAt` property to be created within a 5 minute window of the Platform state timestamp. We use 10 minutes because the window extends 5 minutes in each direction.

### DashPay Incoming Funds Derivation Path

BIP32 introduced derivation paths for keys. BIP43 introduced a purpose field and [DIP9](./dip-0009.md) introduced a feature field that was coin specific.

We can therefore define the following root levels for identity features.

`m / purpose' / coin_type' / feature' / account' /`

The apostrophe signifies hardened paths as defined in BIP32.

Feature will be set to `15'` for all DashPay Incoming Funds derivation paths.

BIP32 and then BIP44 addresses are defined by either being internal (change) or external (receive) addresses. In DashPay there is no requirement for a change address on a relationship, as local BIP44 change addresses can and should be used instead. Therefore, the incoming fund derivation paths will only have one extra derivation on a friendship derivation path to produce addresses.

In order to create provably unique derivation paths per relationship, we must use 256-bit derivation paths, this is described in [DIP14 (Extended Key Derivation using 256-Bit Unsigned Integers)](./dip-0014.md).

The derivation path therefore has the following paths:

`m(userA)/9'/5'/15'/0'/(userA's unique id)/(userB's unique id)/index`

Deconstructed that is:

* 9 hardened / See [DIP9](https://github.com/dashpay/dips/blob/master/dip-0009.md)
* 5 hardened / Coin type
* 15 hardened / Feature
* 0 hardened / Account
* userA's unique id (not hardened)
* userB's unique id (not hardened)
* index of payment address (not hardened)

Making the last three fields non-hardened allows for an extended public key that covers all address spaces of all our contacts for all our identities. This can be used for accounting and also for creating contact requests without having to use a private key.

### Immutability of the Contact Request

One essential aspect of Contact Requests is the fact that they are immutable and can never be deleted. This means they can never be updated or removed from the platform tree once accepted into the state. This is by design. If they were allowed to be mutable, users could change their extended public keys. This would overwrite previous extended public keys.

For recipients this would make the previous extended public keys' associated derivation paths unretrievable. There would then be no way to know the addresses to add to the recipients bloom filter, causing them to fail to know to whom payments were sent. For senders it would not be obvious that there ever was a different previous extended public key. When resyncing they would no longer look for payments to addresses they previously might have received payments on. For end users this would appear to look like transactions were lost.

One drawback of this immutability is the fact that clients can not alter incorrect extended public keys. If a client has sent incorrect extended public keys, that client should send another contact request and update the version number sent to clients.

### Creating a Contact Request

When sending a contact request, a client should create a signed Documents Batch Transition containing a create document instruction and then broadcast (publish) it to Dash Platform. This is done in the following steps:

1. `$ownerId` should be set to the sender's Dash identity unique id which is the same Dash identity that will sign the transition.  
2. `toUserId` should be set to be the recipient's Dash identity unique id.  
3. `senderKeyIndex` should be set to a valid public key index from the sender's identity. This key must allow for a Diffie-Hellman key agreement protocol - currently only secp256k1 Elliptic Curve keys are supported.
4. `recipientKeyIndex` should be set to a valid public key index from the recipient's identity. This key must be of the same type as the sender key and must allow for a Diffie-Hellman key agreement protocol.
5. A shared key should be created using the private key associated with the `senderKeyIndex` and the public key associated with `recipientKeyIndex`.
6. An extended public key should be derived from the wallet master seed which will be for the address space to which the sender will receive payments from the recipient.
7. The extended public key from step 6 should be encrypted to form the `encryptedPublicKey`.
8. `$coreHeightCreatedAt` should be set to the height of the most recent ChainLocked block known by Dash Platform.
9. `$createdAt` should be set to the current system time. Must be within 5 minutes of the most recently mined platform chain block.
10. Once formed, the resulting transition must be signed using a key from the sender's identity.
11. The transition should then be broadcast to the network. This is referred to as Broadcasting the transition.

If a Documents Batch Transition containing a contact request is signed, but not published to Dash Platform within 5 minutes for connectivity or other reasons, then the transition must be recreated and signed again before submission.

### Fetching Contact Requests

When fetching contact requests related to a particular Dash identity's unique id, two queries can be made:

1. Query all sent contact requests where the `$ownerId` matches the unique id in question
2. Query all received contact requests where the `toUserId` property matches the unique id in question

The first time these queries are made, all matching requests will be retrieved regardless of creation date (`$createdAt`). Subsequent queries should be made with `$createdAt` set to 10 minutes before the most recent date of the results from previous queries. This method saves bandwidth by only retrieving the most recent contact requests. This assumes that the client is maintaining the list of contacts in local storage.

### Auto Accept Proof (autoAcceptProof)

Certain situations merit that an identity would like to accept contact requests (i.e. responding with a contact request in the opposite direction) automatically. This could be the case when providing a QR code to scan for someone in close proximity or for a merchant that provides a QR code for their customers to send them payments.

This works by providing a key in the QR code that will later be used to sign the `$ownerId` + `toUserId` + `accountReference` of the contact request and hence prove that the original owner gave this key.

Keys should be provided as data in the following way:

| Name | Size | Example (Using Base58 for 32 byte key) |
| - | - | - |
| key type | 1 byte | 0 |
| timestamp (key index) | 4 bytes | 1605927033 |
| key size | 1 byte | 32 |
| key | 32-64 bytes | 5tG9PYhvPYzxyDb6yA1yQ4rTMUpLDgMF9q4z41pbKWES |

The derivation path for these keys based on [DIP9](./dip-0009.md) is:

`m / purpose' / coin_type' / feature' / timestamp'`

The apostrophe signifies hardened paths as defined in BIP 32. Feature will be set to `16'` for all Auto Accept Proofs.

The derivation path therefore has the following paths:

`m(userA)/9'/5'/16'/timestamp'`

The timestamp used should not be the current timestamp but instead the timestamp at which the auto accept proof should expire. The auto accept proof will contain this timestamp as it is essential for the recipient of a contact request containing an auto-accept proof to later verify the proof.

URIs should encode the above information as referenced in BIP21 and BIP72 with the following modifications:

The Dash username should be referenced as `du`

The Auto accept proof key should be referenced as `dapk`

An example URI for a merchant (BobsPizza) using BIP70-72 could be the following:

`dash:Xcu5iYBH3szP744sQ1RUp3JHTVFHrFVdYu?amount=0.11&du=bobspizza&dapk=13SuoA8Z5tG9PYhvPYzxyDb6yA1yQ4rTMUpLDgMF9q4z41pbKWES&r=https://merchant.com/pay.php?h%3D2a8628fc2fbe`

An example for a URI for a contact request would be:

`dash:?du=bobspizza&dapk=13SuoA8Z5tG9PYhvPYzxyDb6yA1yQ4rTMUpLDgMF9q4z41pbKWES`

The auto accept proof should be formatted the following way:

| Name | Size |
| - | - |
| key type | 1 byte |
| key index | 4 bytes |
| signature size | 1 byte |
| signature | 32-96 bytes |

## The Profile

The ``profile`` document is an important notion for clients in DashPay. It holds all of the public facing information about a DashPay user. In the system, a profile should have the following attributes:

* $ownerId (byte array) - The profile owner identity's unique identifier.
* avatarUrl (string, optional) - A URL to an image that will be the user's avatar or photo.
* avatarHash (byte array, optional) - The SHA-256 hash of the avatar image that is uploaded
* avatarFingerprint (byte array, optional) - The perceptual hash of the avatar image using the difference hash DHash algorithm.
* publicMessage (string, optional) - A public message or a bio that the user can provide to better identify themselves.
* displayName (string, optional) - This display name can include any UTF-8 allowed characters. It is not unique and can be shared by many users. Apps should use this in addition to the username to identify users. Clients should always include the DPNS username that is being paid to in UI confirmation dialogs as it is unique in the system. This DPNS username is recommended to have a high prominence. Clients can also show the display name but it should be less prominent.
* $createdAt (integer) - The timestamp in milliseconds when this document was created.
* $updatedAt (integer) - The timestamp in milliseconds when this document was updated.

Note: Fields prefixed with a `$` sign are special system-wide predefined properties that inherit from the base protocol definition.

### Field Validation Sizes

The Profile Document, like all standard documents, has the byte array `$ownerId` field. The Profile Document also has three string fields along with optional `avatarHash` and `avatarFingerprint` byte array fields.

| Name | Size |
| - | - |
| $ownerId | 32 bytes |
| avatarUrl | 0-2048 characters |
| publicMessage | 0-250 characters |
| displayName | 0-25 characters |
| avatarHash | 32 bytes |
| avatarFingerprint | 8 bytes |

### Avatar URL (avatarUrl)

This URL points to an image stored at a publicly accessible location (e.g., personal server, image hosting site). Clients are advised to not retrieve this image directly but instead use a thumbnail server to display the image in the appropriate size and resolution for the device and screen. Clients are advised to cache these avatars. If the image is unavailable on the thumbnail server, it is recommended that the image should only be retrieved if under a reasonable size limit and if the user has expanded the profile section. The image should not be retrieved in this way when searching for users. Clients are advised to perform local URL sanitization and similar techniques to improve the security of the loaded content. Clients are also advised to have a backup system for determining what to display if no avatar can be retrieved.

### Avatar Hash (avatarHash)

This is the single SHA256 hash of the bytes of the original image referenced by avatar URL. It is an optional field. Clients are advised to use this field when uploading an image.

### Avatar Perceptual Fingerprint (avatarFingerprint)

This is the perceptual hash of the original image using the difference hash DHash algorithm. Various implementations of this hashing algorithm exist in most common languages. The difference hash uses variations in gradients to produce a fingerprint for an image. Clients should compare the Hamming distance between the document and the downloaded thumbnail in order to verify that the thumbnail accurately represents the original image.

### Bio (publicMessage)

This message is any text that the user wants to be publicly visible. It can contain UTF-8 encodable characters from any language as well as spaces, punctuation and symbols.

### Display Name (displayName)

The display name allows a user to specify a more friendly or personal name than the username.  The username (defined in the DPNS domain document) must follow [certain rules](https://github.com/dashpay/dips/blob/master/dip-0012.md#validation-rules-1) and is limited to Latin characters. However, displayName can include characters from any language as well as spaces, punctuation and symbols.

### Timestamps ($createdAt, $updatedAt)

The timestamp in milliseconds (unix epoch time) when the contact request was created or updated. The protocol defined property, `$updatedAt`, is useful when fetching updated profiles.  When querying DAPI in order to find updates to a profile, the query should use an `$updatedAt` timestamp that is greater than the profile's currently known `$updatedAt` timestamp.

### Creating a Profile

The normal procedure of creating and publishing a document create transition should be followed. At least one field between the `avatarUrl`, `publicMessage` and `displayName` must be set. `$createdAt` should be set to the current system time which must be within 5 minutes of the most recently mined platform block. `$updatedAt` must be equal to `$createdAt`.

### Updating a Profile

The normal procedure of creating and publishing a document replace transition should be followed. All fields must be submitted when updating a profile. Fields that are not being updated should be set to their current value. Additionally, one or more of the following fields must be updated: `avatarUrl`, `publishMessage` and/or `displayName`. `$updatedAt` should be set to the current system time which must be within 5 minutes of the most recently mined platform chain block.

### Fetching a Profile

Profiles should be fetched in three scenarios.

The first scenario is when a user is searching for a username during an Add Contact operation. In such cases, the query should use the where clause to retrieve profiles for all identities returned by the DPNS name query. This query is solely based on $ownerId(s) and should resemble `$ownerId in ([OwnerIdArray])`.

The second scenario is when receiving new contact requests. Profiles should be fetched when new contact requests are fetched if the profile for the identity is not yet known. (see [Fetching Contact Requests](#fetching-contact-requests)). This query is also solely based on `$ownerId` and can be batched as in the first scenario if receiving multiple contact requests simultaneously.

The third and final scenario is when checking for an updated profile. Clients are advised to only submit this query when a user has entered the profile page of a contact. Clients can also submit these queries routinely but should not do so more than once a day per contact. They should not be batched. This query is based off of `$ownerId` and `$updatedAt`. The query should be made by querying `$updatedAt` superior to the last `$updatedAt` known for the profile.

## Contact Info

These are the attributes of the `contactInfo` document that allow a user to store private information about a contact. A client should not transmit a contact info document for a user to the network until that user has at least two established contacts. This is to prevent a trivial linking to a corresponding contact request. The fields are as follows:

* $ownerId (byte array) - The unique id of the user.
* rootEncryptionKeyIndex (integer) - The index of the user's key that is used to derive keys that will be used to encrypt the contact's user id in encToUserId and the private data.
* derivationEncryptionKeyIndex (integer) - The index at which to derive the root encryption key.
* encToUserId (byte array) - The encrypted unique id bytes (32) of the contact. AES-256-ECB should be used.
* privateData (byte array) - This is encrypted using AES-256-CBC. It has the following fields:
  * version (uInt32) - The version of this private data.
  * aliasName (String) - The nickname that this user has chosen for this contact.
  * note (String) - A note that this user has written about this contact.
  * displayHidden (uInt8) - Whether or not the user has chosen to hide or ignore this contact.
  * acceptedAccounts (array of uInt32) - This should be an array of all accepted accounts that are not on version 0.
* $updatedAt (integer) - The timestamp in milliseconds when this document was updated.
* $createdAt (integer) - The timestamp in milliseconds when this document was created.

Note: Fields prefixed with a `$` sign are special system-wide predefined properties that inherit from the base protocol definition.

### Binary Field Validation Sizes

The Contact Info has three binary fields using byte arrays. Validation sizes are as follows:

| Name | Size |
| - | - |
| $ownerId | 32 bytes |
| privateData | 48-2048 bytes |
| encToUserId | 32 bytes |

### Deriving the Encryption Keys

Two fields in our document need to be encrypted on creation: `encToUserId` and `privateData`. Because the destination contact (`toUserId`) could potentially be guessed based on user or client actions and also because the pool of users in DashPay might start out small, it is imperative that the encryption key used be hardened and never reused. Hence the keys encrypting `encToUserId` and `privateData` must be different and unique.

In order to create these keys, a client must start with a key registered in Dash Platform. The index of this key is set in the `encryptionKeyIndex`. Two private keys should then be derived from this root key using the CKDpriv function described in BIP32. Hardened derivation should be used in both cases. The index used in the derivation should be used sequentially and should be unique to the `$ownerId`.

The path used for the key encrypting encToUserId should be:

`rootEncryptionKey/(2^16)'/index'`

The path used for the key encrypting privateData should be:

`rootEncryptionKey/(2^16 + 1)'/index'`

2<sup>16</sup> is used as an offset to discount other potential derivations of this key in other applications.

### Encrypting the contact unique identifier (encToUserId)

AES-256-ECB encryption should be used here. Electronic Code Book (ECB) mode is generally not secure if keys are reused or if encrypted data is not random. In our case however the contact unique identifier we are encrypting is made with the SHA256 hash function. It can therefore be assumed that the contact unique identifier appears random in nature. Since the key will also not be reused for other purposes, ECB mode can be used securely here.

The advantage of using ECB mode is that there is no need to supply an initialization vector.

### Versioning of Private Data

The fields are defined in this document for version zero. Future updates to this proposal or new improvement proposals might introduce additional versions. Version should be set to zero if no other new proposals have been made.

This version field should be decomposed into two subfields, major and minor with `version = major << 16 | minor`. Major version changes are incompatible and if a client does not understand them the whole contact info should be discarded. Minor version changes that a client does not understand most likely reflect additional fields. If a client receives a contact info document and has not been updated to support the minor version number, it should still be able to parse the first fields of the private Data. It should ignore data past the final field known in the version.

### Alias Name

The Alias Name is a nickname that a user can give one of their contacts. This can be essential to recognize contacts that have both their DPNS usernames and their display names set to strings that don't clearly identify them.

### Note

The note is a field to add specific notes to a contact. For example a note could be where the two users met, or any information that the user wants to remember about the contact.

### Display Hidden

Contacts in DashPay cannot be banned from another user once accepted. Instead they should be marked as hidden. DashPay enabled applications should hide from the user's contact list all contacts marked as hidden.

### Accepted Accounts

The DashPay system allows for multiple contact requests between two identities. An obvious attack is to send a very high number of contact requests to an identity that had previously sent a contact request in the opposite direction. Without mitigation, these contact requests would pollute and expand the client's bloom filter to its max capacity. In order to fix this, a client should only add to its bloom filter the first contact request from a contact. If additional contact requests have been made, they must be accepted by the user. If accepted by the user, the account reference of the newly accepted contact request should be added to the array of accepted accounts.

This array should be serialized by prepending the varInt length of the array, followed by all uInt32s in the array.

### Encrypting Private Data

AES-256-CBC encryption using the derived encrypted key should be used to encrypt the private data. In order to do so, the private data should be serialized in the same way as done for Dash message data ([example for strings](https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_string)).

### Creating Contact Info

The normal procedure of creating and publishing a document create transition should be followed. `$createdAt` should be set to the current system time which must be within 5 minutes of the most recently mined platform block. `$updatedAt` must be equal to `$createdAt`.

### Updating Contact Info

The normal procedure of creating and publishing a document update transition should be followed. `$updatedAt` should be set to the current system time which must be within 5 minutes of the most recently mined platform block. `$updatedAt` must be superior to the previous `$updatedAt`.

### Fetching Contact Info

Contact Info documents should be fetched prior to fetching contact requests and profiles. This is so Contacts do not pop in and out of the UI based on the Display Hidden property. This query is based off of `$ownerId` and `$updatedAt`. The query should be made by querying `$updatedAt` superior to 10 minutes before the last known `$updatedAt`. `$updatedAt` should be set to zero if querying for the first time.

# Example Steps to Establish a Contact

1. Bob installs wallet software that supports DashPay.
2. Bob registers a username through DPNS which first requires the registration of an identity.
3. Bob finds Carol by her username on the network. Behind the scenes this search returns the unique identifier for Carol's identity. For more information see the [Dash Platform Name Service (DPNS) DIP](https://github.com/dashpay/dips/blob/master/dip-0012.md).
4. Bob sends a contact request to Carol. This establishes a one way relationship from Bob to Carol.
5. Carol accepts the request by sending a contact request back to Bob. This establishes a one way relationship from Carol to Bob.
6. Bob and Carol are now contacts of one another and can make payments to each other. Since both have established one way relationships with each other, they now have a two way relationship. If Bob gets a new phone, he can use his recovery phrase from step one and restore his wallet, contacts (including Carol) and payments to and from his contacts.

# Order of Synchronization

One slightly trickier aspect of DashPay is synchronization that combines both layer 1 and layer 2. Clients should implement [DIP16 (Simple Payment Verification Wallet Headers First Synchronization)](./dip-0016.md). In doing so, Dash Platform data requests will happen after the deterministic masternode lists and quorums have been loaded. This is done by retrieving Dash identities sequentially from wallet-derived keys as described in [DIP13 (Identities in Hierarchical Deterministic Wallets)](./dip-0013.md). During the Sync Blocks Retrieval Phase and the Synced Phase, and as transactions and blocks come in on layer 1, clients should look for credit funding transactions that correspond to keys in the wallet used for registration (derivation path explained in DIP13). If one is found either in a block or from the mempool, and the Dash identity unique id corresponding to the credit funding transaction is not yet known by the wallet, the sync on layer 1 should be paused while the client requests information from layer 2.

A client should first retrieve information about the Dash identity. At that point it can get both the profile associated with the Dash identity, and incoming and outgoing contact requests. For each contact request, Dash identity information of the other parties should be requested along with their profiles.

Derivation paths should be constructed for all accepted contact requests. There are two ways for a contact request to be deemed as accepted: Either it is the first incoming contact request from a contact to whom the user had already sent a contact request, or it can be marked as accepted in the contact info document for that contact. All outgoing contact requests are considered accepted by default in the context of the sender.

For outgoing contact requests, derivation paths should be constructed by deriving the master contacts derivation path extended public key as described above. For incoming derivation paths, the derivation path should be constructed without full knowledge of the starting path but with the extended public key retrieved by the contact request after decryption. This extended public key can be derived to give an address space for sending to the contact in question.

Once all the derivation paths are known, address spaces can be constructed. We recommend a gap limit of 10 at this stage, which means to load 10 addresses past the last used address. For initial sync this will be 10 since at this point no addresses will have yet been seen to be used. These addresses should then be inserted into rebuilt peer bloom filters as defined in BIP37. Sync on layer 1 can then be resumed with the complete bloom filters. It is advised to also change peers in this process so nodes cannot easily associate payments to the identities of the sender and recipient.

The wallet should therefore contain the following address spaces that should be added to bloom filters on connection with peers:

* BIP44 (external, change)
* An address space for each outgoing contact request from each Dash identity. This address space should be derived from the wallet mnemonic. These addresses will receive payments.
* An address space for each incoming contact request for each Dash identity. If the sender is not a Dash identity derived from the wallet (a rare case where both the sender and recipient are in the same wallet), then this address space should be derived from the contact request extended public key after decryption.

It is essential to also re-request blocks at the minimum of all `$coreHeightCreatedAt` values of any new incoming or outgoing contact requests. It is advised to re-request a little more than this minimum block to preserve the probabilistic nature of false positives in the bloom filter. If the first block of a client always returned a transaction, then nodes would learn that this transaction is most likely not a false positive. We should do this unless we are within 10 blocks of the chain tip. In that case, re-requesting more than from the minimum block would serve little purpose as any incoming transactions close to the chain tip are highly probable to not be false positives. We recommend requesting from the last millennial block (mod 1000 = 0).

# Copyright

Copyright (c) 2020 Dash Core Group, Inc. [Licensed under the MIT License](https://opensource.org/licenses/MIT)
